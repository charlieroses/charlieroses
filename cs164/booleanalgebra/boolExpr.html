<!DOCTYPE html>
<html>
<head>
	<title>Introduction to Computer Science</title>
	<base href="/cs164/">
	<link rel="stylesheet" href="structure.css">
	<link rel="stylesheet" href="styles.css">
	<link rel="stylesheet" href="tables.css">
	<link rel="stylesheet" href="colors.css">
	<link rel="stylesheet" href="booleanalgebra/booleanalgebra.css">
<meta http-equiv="Content-Type" content="text/html;charset=UTF-8" />
<script type="text/javascript" src="booleanalgebra/simcir.js"></script>
<link rel="stylesheet" type="text/css" href="booleanalgebra/simcir.css" />
<script type="text/javascript" src="booleanalgebra/simcir-basicset.js"></script>
<link rel="stylesheet" type="text/css" href="booleanalgebra/simcir-basicset.css" />
<script type="text/javascript" src="booleanalgebra/simcir-library.js"></script>
</head>
<body>
<div id="sidebar">
	<div class="content">
	</div>
	<hr>
	<div class="content">
		<a href="introduction"><b>Introduction</b></a>
	</div>
	<hr>
	<div class="content">
		<a href="https://charlierose.dev"><b>My Site</b></a>
	</div>
	<hr>
	<div class="content">
		<a href="https://charlierose.dev/ref/"><b>Other Notes and Reference</b></a>
	</div>
	<hr>
	<div class="content">
		<a href="answers"><b>Practice Problem Answers</b></a>
	</div>
	<hr>
	<div class="content">
		<a href="numbers/"><b>Chapter 1 :</b> Number Bases</a>
		<a href="numbers/baseTen.html"><b>1.1 :</b> Base-10</a>
		<a href="numbers/baseTwo.html"><b>1.2 :</b> Base-2</a>
		<a href="numbers/baseSixteen.html"><b>1.3 :</b> Base-16</a>
		<a href="numbers/colors.html"><b>1.4 :</b> HTML Colors</a>
	</div>
	<hr>
	<div class="content">
		<a href="binary/"><b>Chapter 2 :</b> Binary</a>
		<a href="binary/convertBin.html"><b>2.1 :</b> Converting Between Bases</a>
		<a href="binary/negativebin.html"><b>2.2 :</b> Negative Numbers</a>
		<a href="binary/fracBinary.html"><b>2.3 :</b> Fractional Binary</a>
		<a href="binary/addSubBin.html"><b>2.4 :</b> Addition and Subtration</a>
	</div>
	<hr>
	<div class="content">
		<a href="ascii/"><b>Chapter 3 :</b> Character Sets</a>
		<a href="ascii/ascii.html"><b>3.1 :</b> ASCII</a>
		<a href="ascii/unicode.html"><b>3.2 :</b> Unicode</a>
	</div>
	<hr>
	<div class="content">
		<a href="booleanalgebra/"><b>Chapter 4 :</b> Boolean Algebra</a>
		<a href="booleanalgebra/boolEng.html"><b>4.1 :</b> An Overview</a>
		<a href="booleanalgebra/ttIntro.html"><b>4.2 :</b> Basic Operators</a>
		<a href="booleanalgebra/not.html"><b>4.2.1 :</b> Not</a>
		<a href="booleanalgebra/or.html"><b>4.2.2 :</b> Or</a>
		<a href="booleanalgebra/and.html"><b>4.2.3 :</b> And</a>
		<a href="booleanalgebra/nor.html"><b>4.2.4 :</b> Nor</a>
		<a href="booleanalgebra/nand.html"><b>4.2.5 :</b> Nand</a>
		<a href="booleanalgebra/xor.html"><b>4.2.6 :</b> Xor</a>
		<a href="booleanalgebra/boolExpr.html"><b>4.3 :</b> Complex Expressions</a>
		<a href="booleanalgebra/halfAdder.html"><b>4.4 :</b> Half Adder</a>
		<a href="booleanalgebra/fullAdder.html"><b>4.5 :</b> Full Adder</a>
		<a href="booleanalgebra/alu.html"><b>4.6 :</b> Arithmetic Logic Unit</a>
		<a href="booleanalgebra/circuit.html"><b>4.7 :</b> Digital Logic Workbench</a>
		<a href="booleanalgebra/minecraft.html"><b>4.8 :</b> Minecraft</a>
	</div>
	<hr>
	<div class="content">
		<a href="cardiac/"><b>Chapter 5 :</b> The CARDIAC</a>
		<a href="cardiac/hardware.html"><b>5.1 :</b> The Hardware</a>
		<a href="cardiac/program.html"><b>5.2 :</b> Programming the CARDIAC</a>
		<a href="cardiac/assMach.html"><b>5.3 :</b> Assembly and Machine Language</a>
	</div>
	<hr>
	<div class="content">
		<a href="languages/"><b>Chapter 6 :</b> Languages</a>
		<a href="languages/langInfo.html"><b>6.1 :</b> Processing Language</a>
		<a href="languages/markup.html"><b>6.2 :</b> Markup Languages</a>
		<a href="languages/program.html"><b>6.3 :</b> Programming Languages</a>
		<a href="languages/tranq.html"><b>6.4 :</b> Tranquility</a>
		<a href="languages/tranqc.html"><b>6.4.1 :</b> TRANQC (1)</a>
		<a href="languages/alloc.html"><b>6.4.2 :</b> ALLOC (3)</a>
		<a href="languages/button.html"><b>6.4.3 :</b> BUTTON (3)</a>
		<a href="languages/html.html"><b>6.4.4 :</b> HTML (3)</a>
		<a href="languages/i2s.html"><b>6.4.5 :</b> I2S (3)</a>
		<a href="languages/img.html"><b>6.4.6 :</b> IMG (3)</a>
		<a href="languages/label.html"><b>6.4.7 :</b> LABEL(3)</a>
		<a href="languages/print.html"><b>6.4.8 :</b> PRINT (3)</a>
		<a href="languages/random.html"><b>6.4.9 :</b> RANDOM (3)</a>
		<a href="languages/read.html"><b>6.4.10 :</b> READ (3)</a>
		<a href="languages/table.html"><b>6.4.11 :</b> TABLE (3)</a>
		<a href="languages/timer.html"><b>6.4.12 :</b> TIMER (3)</a>
		<a href="languages/state.html"><b>6.5 :</b> State and State Machines</a>
	</div>
</div>
<div id="main">
	<div class="content">
		<br>
		<div class="navigation" id="top">
		<div class="prev">
			<a href="booleanalgebra/xor.html">Previous Section</a> : Xor : 4.2.6
		</div>
		<div class="next">
			4.4 : Half Adder : <a href="booleanalgebra/halfAdder.html">Next Section</a>
		</div>
		</div>
		<br>
		<br>
	</div>
	<hr>
	<div class="content">
		<span style="color:#FF0000"><b>Warning: CSS May Be Broken.</b>
		My apologies for any issues this may cause.
		I wrote bad code a very long time ago and it's taking a while to update
		it.
		</span>
	</div>
	<hr>
	<div class="content">
		<h1>4.3 : Complex Expressions</h1>
	</div>
	<hr>
	<div class="content">
<p>Now that we know our basic operators, we can form much larger expressions. We use larger expressions to do more math and create processors like the ones in your computer. But how do we evaluate these expressions?</p>
<center>
<code>(P ∨ Q)' ∧ (R ∧ (P' ∨ Q))</code>
</center>
<p>We have two options. In both options, we're going to build a truth table, but we're going to do it in different ways.</p>
<h3 id="option-a">Option A</h3>
<p>We can plug and chug. For each row of the truth table, we can plug in values for <code>P</code>, <code>Q</code>, and <code>R</code> and simplify.</p>
<center>
<table>
<colgroup>
<col span="1" class="red">
</colgroup>
<thead>
<tr>
<th>
</th>
<th>
</th>
</tr>
</thead>
<tbody>
<tr>
<th>
</th>
<td>
<code>(P ∨ Q)' ∧ (R ∧ (P' ∨ Q))</code>
</td>
</tr>
<tr>
<th>
</th>
<td>
<code>(0 ∨ 0)' ∧ (0 ∧ (0' ∨ 0))</code>
</td>
</tr>
<tr>
<th>
</th>
<td>
<code>(0)' ∧ (0 ∧ (1 ∨ 0))</code>
</td>
</tr>
<tr>
<th>
</th>
<td>
<code>1 ∧ (0 ∧ (1))</code>
</td>
</tr>
<tr>
<th>
</th>
<td>
<code>1 ∧ 0</code>
</td>
</tr>
<tr>
<th>
</th>
<td>
<code>0</code>
</td>
</tr>
</tbody>
</table>
</center>
<p>Then repeat for each row of the truth table</p>
<h3 id="option-b">Option B</h3>
<p>We break each expression into smaller expressions and add columns to our truth table. In the above expression, we cannot evaluate <code>(P ∨ Q)'</code> without first evalulating <code>P ∨ Q</code>. To make these operations easier, we add a column for <code>P ∨ Q</code> to our truth table and find it's value for each row. Now, when we add <code>(P ∨ Q)'</code>, instead of needed to repeform the OR calculation, we can just NOT the previous column. We continue doing this for all of the parts of the expression and build our way up:</p>
<center>
<table>
<colgroup>
<col span="1" class="red">
<col span="2">
<col span="1" class="gray">
<col span="4">
<col span="1" class="gray">
</colgroup>
<thead>
<tr>
<th>
</th>
<th colspan="3">
Inputs
</th>
<th colspan="5">
Intermediate Steps
</th>
<th>
Output
</th>
</tr>
<tr>
<th>
</th>
<th>
P
</th>
<th>
Q
</th>
<th>
R
</th>
<th>
P ∨ Q
</th>
<th>
(P ∨ Q)'
</th>
<th>
P'
</th>
<th>
P' ∨ Q
</th>
<th>
R ∧ (P' ∨ Q)
</th>
<th>
(P ∨ Q)' ∧ (R ∧ (P' ∨ Q))
</th>
</tr>
</thead>
<tbody class="lined">
<tr>
<th>
</th>
<td class="lowlighttable">
0
</td>
<td class="lowlighttable">
0
</td>
<td class="lowlighttable">
0
</td>
<td>
0
</td>
<td>
1
</td>
<td>
1
</td>
<td>
1
</td>
<td>
0
</td>
<td class="lowlighttable">
0
</td>
</tr>
<tr>
<th>
</th>
<td class="lowlighttable">
0
</td>
<td class="lowlighttable">
0
</td>
<td class="lowlighttable">
1
</td>
<td>
0
</td>
<td>
1
</td>
<td>
1
</td>
<td>
1
</td>
<td>
1
</td>
<td class="lowlighttable">
1
</td>
</tr>
<tr>
<th>
</th>
<td class="lowlighttable">
0
</td>
<td class="lowlighttable">
1
</td>
<td class="lowlighttable">
0
</td>
<td>
1
</td>
<td>
0
</td>
<td>
1
</td>
<td>
1
</td>
<td>
0
</td>
<td class="lowlighttable">
0
</td>
</tr>
<tr>
<th>
</th>
<td class="lowlighttable">
0
</td>
<td class="lowlighttable">
1
</td>
<td class="lowlighttable">
1
</td>
<td>
1
</td>
<td>
0
</td>
<td>
1
</td>
<td>
1
</td>
<td>
1
</td>
<td class="lowlighttable">
0
</td>
</tr>
<tr>
<th>
</th>
<td class="lowlighttable">
1
</td>
<td class="lowlighttable">
0
</td>
<td class="lowlighttable">
0
</td>
<td>
1
</td>
<td>
0
</td>
<td>
0
</td>
<td>
0
</td>
<td>
0
</td>
<td class="lowlighttable">
0
</td>
</tr>
<tr>
<th>
</th>
<td class="lowlighttable">
1
</td>
<td class="lowlighttable">
0
</td>
<td class="lowlighttable">
1
</td>
<td>
1
</td>
<td>
0
</td>
<td>
0
</td>
<td>
0
</td>
<td>
0
</td>
<td class="lowlighttable">
0
</td>
</tr>
<tr>
<th>
</th>
<td class="lowlighttable">
1
</td>
<td class="lowlighttable">
1
</td>
<td class="lowlighttable">
0
</td>
<td>
1
</td>
<td>
0
</td>
<td>
0
</td>
<td>
1
</td>
<td>
0
</td>
<td class="lowlighttable">
0
</td>
</tr>
<tr>
<th>
</th>
<td class="lowlighttable">
1
</td>
<td class="lowlighttable">
1
</td>
<td class="lowlighttable">
1
</td>
<td>
1
</td>
<td>
0
</td>
<td>
0
</td>
<td>
1
</td>
<td>
1
</td>
<td class="lowlighttable">
0
</td>
</tr>
</tbody>
</table>
</center>
	</div>
	<hr>
	<div class="content">
<h2 id="simplifying-expressions">Simplifying Expressions</h2>
<p>When we have these really long boolean expressions, they can get a little unwieldy. There are ways to simplify boolean expressions, similar to the ways we simplify algebraic expressions with the associative, commutative, and distributive properties. <em>Note: I switched up my notation between sections. Sorry not sorry</em></p>
<center>
<table>
<colgroup>
<col span="1" class="red">
</colgroup>
<thead>
<tr>
<th>
</th>
<th>
AND
</th>
<th>
OR
</th>
</tr>
</thead>
<tbody class="lined">
<tr>
<th>
Identity
</th>
<td>
<code>1a ≡ a</code>
</td>
<td>
<code>0 + a ≡ a</code>
</td>
</tr>
<tr>
<th>
Null Elements
</th>
<td>
<code>0a ≡ 0</code>
</td>
<td>
<code>1 + a ≡ 1</code>
</td>
</tr>
<tr>
<th>
Complement
</th>
<td>
<code>aa' ≡ 0</code>
</td>
<td>
<code>a + a' ≡ 1</code>
</td>
</tr>
<tr>
<th>
Indempotent
</th>
<td>
<code>aa ≡ a</code>
</td>
<td>
<code>a + a ≡ a</code>
</td>
</tr>
<tr>
<th>
Commutative
</th>
<td>
<code>ab ≡ ba</code>
</td>
<td>
<code>a + b ≡ b + a</code>
</td>
</tr>
<tr>
<th>
Associative
</th>
<td>
<code>(ab)c ≡ a(bc)</code>
</td>
<td>
<code>(a + b) + c ≡ a + (b + c)</code>
</td>
</tr>
<tr>
<th>
Distributive
</th>
<td>
<code>a(b + c) ≡ ab + ac</code>
</td>
<td>
<code>a + (bc) ≡ (a + b)(a + c)</code>
</td>
</tr>
<tr>
<th>
Absorption
</th>
<td>
<code>a(a + b) ≡ a</code>
</td>
<td>
<code>a + ab ≡ a</code>
</td>
</tr>
<tr>
<th>
De Morgan's Law
</th>
<td>
<code>(ab)' ≡ a' + b'</code>
</td>
<td>
<code>(a + b)' ≡ a'b'</code>
</td>
</tr>
<tr>
<th>
Involution
</th>
<td colspan="2">
<code>(a')' ≡ a</code>
</td>
</tr>
</tbody>
</table>
</center>
<p>This may look extremely overwhelming at first, but I promise, it's not that bad. A lot of these are more intuitive than you'd think. Let's look at the truth tables for the identities:</p>
<center>
<div class="container">
<table>
<colgroup>
<col span="1" class="red">
<col span="1">
<col span="1" class="gray">
</colgroup>
<thead>
<tr>
<th>
</th>
<th>
a
</th>
<th>
1
</th>
<th>
1a
</th>
</tr>
</thead>
<tbody>
<tr>
<th>
</th>
<td>
0
</td>
<td>
1
</td>
<td>
0
</td>
</tr>
<tr>
<th>
</th>
<td>
1
</td>
<td>
1
</td>
<td>
1
</td>
</tr>
</tbody>
</table>
<table>
<colgroup>
<col span="1" class="red">
<col span="1">
<col span="1" class="gray">
</colgroup>
<thead>
<tr>
<th>
</th>
<th>
a
</th>
<th>
1
</th>
<th>
0 + a
</th>
</tr>
</thead>
<tbody>
<tr>
<th>
</th>
<td>
0
</td>
<td>
0
</td>
<td>
0
</td>
</tr>
<tr>
<th>
</th>
<td>
1
</td>
<td>
0
</td>
<td>
1
</td>
</tr>
</tbody>
</table>
</div>
</center>
<p>As you can see, after both operations, our output is the same as our <code>a</code> input. Go through the truth tables for the rest of these properties. They're pretty neat.</p>
<p>Let's actually apply these rules and see them in action. Remember our really nasty boolean expression at the top? Let's see if we can make it a little less nasty with some simplification rules. First, let's fix that notation up:</p>
<center>
<code>(P ∨ Q)' ∧ (R ∧ (P' ∨ Q)) --&gt; (P + Q)'(R(P' + Q))</code>
</center>
<p>Much better, let's see what we can do here:</p>
<center>
<table>
<colgroup>
<col span="1" class="red">
</colgroup>
<thead>
<tr>
<th>
</th>
<th>
</th>
<th>
</th>
</tr>
</thead>
<tbody>
<tr>
<th>
De Morgan's Law
</th>
<td>
<code><span class="hi">(P + Q)'</span>(R(P' + Q))</code>
</td>
<td>
<code><span class="hi">(P'Q')</span>(R(P' + Q))</code>
</td>
</tr>
<tr>
<th>
Distributive AND
</th>
<td>
<code>(P'Q')<span class="hi">(R(P' + Q))</span></code>
</td>
<td>
<code>(P'Q')<span class="hi">(RP' + RQ)</span></code>
</td>
</tr>
<tr>
<th>
Distributive AND
</th>
<td>
<code><span class="hi">(P'Q')(RP' + RQ)</span></code>
</td>
<td>
<code><span class="hi">P'Q'RP' + P'Q'RQ</span></code>
</td>
</tr>
<tr>
<th>
Commutative AND
</th>
<td>
<code><span class="hi">P'Q'RP'</span> + P'Q'RQ</code>
</td>
<td>
<code><span class="hi">P'P'Q'R</span> + P'Q'RQ</code>
</td>
</tr>
<tr>
<th>
Indempotent AND
</th>
<td>
<code><span class="hi">P'P'</span>Q'R + P'Q'RQ</code>
</td>
<td>
<code><span class="hi">P'</span>Q'R + P'Q'RQ</code>
</td>
</tr>
<tr>
<th>
Commutative AND
</th>
<td>
<code>P'Q'R + <span class="hi">P'Q'RQ</span></code>
</td>
<td>
<code>P'Q'R + <span class="hi">P'Q'QR</span></code>
</td>
</tr>
<tr>
<th>
Complement AND
</th>
<td>
<code>P'Q'R + P'<span class="hi">Q'Q</span>R</code>
</td>
<td>
<code>P'Q'R + P'<span class="hi">0</span>R</code>
</td>
</tr>
<tr>
<th>
Null Elements AND
</th>
<td>
<code>P'Q'R + <span class="hi">P'0R</span></code>
</td>
<td>
<code>P'Q'R + <span class="hi">0</span></code>
</td>
</tr>
<tr>
<th>
Identity OR
</th>
<td>
<code><span class="hi">P'Q'R + 0</span></code>
</td>
<td>
<code><span class="hi">P'Q'R</span></code>
</td>
</tr>
</tbody>
</table>
</center>
<p>Well that's <em>much</em> easier to read, but how can we be sure that <code>P'Q'R</code> is actually equivalent to <code>(P + Q)'(R(P' + Q))</code>? With a truth table of course!</p>
<center>
<table>
<colgroup>
<col span="1" class="red">
<col span="2">
<col span="1" class="gray">
<col span="1" class="gray">
</colgroup>
<thead>
<tr>
<th>
</th>
<th>
P
</th>
<th>
Q
</th>
<th>
R
</th>
<th>
(P + Q)'(R(P' + Q))
</th>
<th>
P'Q'R
</th>
</tr>
</thead>
<tbody>
<tr>
<th>
</th>
<td>
0
</td>
<td>
0
</td>
<td>
0
</td>
<td class="lowlighttable">
0
</td>
<td class="lowlighttable">
0
</td>
</tr>
<tr>
<th>
</th>
<td>
0
</td>
<td>
0
</td>
<td>
1
</td>
<td class="lowlighttable">
1
</td>
<td class="lowlighttable">
1
</td>
</tr>
<tr>
<th>
</th>
<td>
0
</td>
<td>
1
</td>
<td>
0
</td>
<td class="lowlighttable">
0
</td>
<td class="lowlighttable">
0
</td>
</tr>
<tr>
<th>
</th>
<td>
0
</td>
<td>
1
</td>
<td>
1
</td>
<td class="lowlighttable">
0
</td>
<td class="lowlighttable">
0
</td>
</tr>
<tr>
<th>
</th>
<td>
1
</td>
<td>
0
</td>
<td>
0
</td>
<td class="lowlighttable">
0
</td>
<td class="lowlighttable">
0
</td>
</tr>
<tr>
<th>
</th>
<td>
1
</td>
<td>
0
</td>
<td>
1
</td>
<td class="lowlighttable">
0
</td>
<td class="lowlighttable">
0
</td>
</tr>
<tr>
<th>
</th>
<td>
1
</td>
<td>
1
</td>
<td>
0
</td>
<td class="lowlighttable">
0
</td>
<td class="lowlighttable">
0
</td>
</tr>
<tr>
<th>
</th>
<td>
1
</td>
<td>
1
</td>
<td>
1
</td>
<td class="lowlighttable">
0
</td>
<td class="lowlighttable">
0
</td>
</tr>
</tbody>
</table>
</center>
	</div>
	<hr>
	<div class="content">
<h2 id="sum-of-min-terms">Sum of Min Terms</h2>
<p>You may find yourself thinking &quot;Hmmm, I know how to turn an expression into a truth table, but what if I have a truth table? How do I get an expression from it?&quot; Well I'm glad you <del>let me create hypothetical questions for you</del> asked Let's look at this completely random truth table:</p>
<center>
<table>
<colgroup>
<col span="1" class="red">
<col span="1">
<col span="1" class="gray">
</colgroup>
<thead>
<tr>
<th>
</th>
<th>
x
</th>
<th>
y
</th>
<th>
o
</th>
</tr>
</thead>
<tbody>
<tr>
<th>
</th>
<td>
0
</td>
<td>
0
</td>
<td class="lowlighttable">
0
</td>
</tr>
<tr>
<th>
</th>
<td>
0
</td>
<td>
1
</td>
<td class="lowlighttable">
1
</td>
</tr>
<tr>
<th>
</th>
<td>
1
</td>
<td>
0
</td>
<td class="lowlighttable">
1
</td>
</tr>
<tr>
<th>
</th>
<td>
1
</td>
<td>
1
</td>
<td class="lowlighttable">
0
</td>
</tr>
</tbody>
</table>
</center>
<p>You may recognize this as XOR, but as we covered before, XOR is a derived gate, its a logic gate created by combining our basic AND, OR, and NOT operators. How can we use this truth table to figure out how to compute <code>o</code> with only AND, OR, and NOT gates? We'll use a <strong>sum of min-terms</strong>. A sum of min-terms is fairly self explanatory once you understand what it is. We're going to find all the smallest (minimum) terms needed to create the expression and use an OR (<code>+</code>) to combine them. So how do we actually do this?</p>
<p>First, identify your true rows:</p>
<center>
<table>
<colgroup>
<col span="1" class="red">
<col span="1">
<col span="1" class="gray">
</colgroup>
<thead>
<tr>
<th>
</th>
<th>
x
</th>
<th>
y
</th>
<th>
o
</th>
</tr>
</thead>
<tbody>
<tr>
<th>
</th>
<td>
0
</td>
<td>
0
</td>
<td>
0
</td>
</tr>
<tr>
<th>
</th>
<td>
<span class="hi">0</span>
</td>
<td>
<span class="hi">1</span>
</td>
<td>
<span class="hi">1</span>
</td>
</tr>
<tr>
<th>
</th>
<td>
<span class="hi">1</span>
</td>
<td>
<span class="hi">0</span>
</td>
<td>
<span class="hi">1</span>
</td>
</tr>
<tr>
<th>
</th>
<td>
1
</td>
<td>
1
</td>
<td>
0
</td>
</tr>
</tbody>
</table>
</center>
<p>We'll notice <code>o</code> is true in two situations: when <code>x=0,y=1</code> and when <code>x=1,y=0</code>. Let's look at <code>x=0,y=1</code> first. I want to write an expression that is true for <em>only</em> this one case and false for all other combinations.</p>
<p>What boolean operator is true in only one row?</p>
<p>If you thought <span class="hide">AND</span>, you're correct.</p>
<p><code>x AND y</code> is only true when <code>x=1,y=1</code>. However, we want an expression that's true only when <code>x=0,y=1</code>. To get this, we'll simply apply a NOT to <code>x</code> to get:</p>
<center>
<table>
<colgroup>
<col span="1" class="red">
<col span="1">
<col span="1" class="gray">
</colgroup>
<thead>
<tr>
<th>
</th>
<th>
x
</th>
<th>
y
</th>
<th>
x'y
</th>
</tr>
</thead>
<tbody>
<tr>
<th>
</th>
<td>
0
</td>
<td>
0
</td>
<td>
0
</td>
</tr>
<tr>
<th>
</th>
<td>
<span class="hi">0</span>
</td>
<td>
<span class="hi">1</span>
</td>
<td>
<span class="hi">1</span>
</td>
</tr>
<tr>
<th>
</th>
<td>
1
</td>
<td>
0
</td>
<td>
0
</td>
</tr>
<tr>
<th>
</th>
<td>
1
</td>
<td>
1
</td>
<td>
0
</td>
</tr>
</tbody>
</table>
</center>
<p>Now we've isolated one of the true rows. We can apply this same concept to our <code>x=1,y=0</code> row to get <code>xy'</code>. This gives us two min-terms: <code>x'y</code> and <code>xy'</code>. We can now use an OR to combine these to get the resulting sum of min-terms <code>x'y + xy'</code>. Don't believe me? Let's look at the truth table:</p>
<center>
<table>
<colgroup>
<col span="1" class="red">
<col span="1">
<col span="1" class="gray">
<col span="1">
<col span="1" class="gray">
</colgroup>
<thead>
<tr>
<th>
</th>
<th>
x
</th>
<th>
y
</th>
<th>
x'y
</th>
<th>
xy'
</th>
<th>
o = x'y + xy'
</th>
</tr>
</thead>
<tbody>
<tr>
<th>
</th>
<td class="lowlighttable">
0
</td>
<td class="lowlighttable">
0
</td>
<td>
0
</td>
<td>
0
</td>
<td class="lowlighttable">
0
</td>
</tr>
<tr>
<th>
</th>
<td class="lowlighttable">
0
</td>
<td class="lowlighttable">
1
</td>
<td>
1
</td>
<td>
0
</td>
<td class="lowlighttable">
1
</td>
</tr>
<tr>
<th>
</th>
<td class="lowlighttable">
1
</td>
<td class="lowlighttable">
0
</td>
<td>
0
</td>
<td>
1
</td>
<td class="lowlighttable">
1
</td>
</tr>
<tr>
<th>
</th>
<td class="lowlighttable">
1
</td>
<td class="lowlighttable">
1
</td>
<td>
0
</td>
<td>
0
</td>
<td class="lowlighttable">
0
</td>
</tr>
</tbody>
</table>
</center>
<p>And there we go! We got the exact same thing we started with! This works for boolean expressions with more variables too. Later, you'll see the full adder which takes in three inputs. Once you've read that section, try to make a sum of min-terms for its truth table. Come back here to verify your answer:</p>
<p>Carry: <span class="hide"><code>x'yc + xy'c + xyc' + xyc</code></span></p>
<p>Sum: <span class="hide"><code>x'y'c + x'yc' + xy'c' + xyc</code></span></p>
	</div>
	<hr>
	<div class="content">
		<center>
		<a href="booleanalgebra/boolExpr.html#top">Back To Top</a>
		</center>
	</div>
	<hr>
	<div class="content">
		<br>
		<div class="navigation" id="bottom">
		<div class="prev">
			<a href="booleanalgebra/xor.html">Previous Section</a> : Xor : 4.2.6
		</div>
		<div class="next">
			4.4 : Half Adder : <a href="booleanalgebra/halfAdder.html">Next Section</a>
		</div>
		</div>
		<br>
		<br>
	</div>
</div>
</body>
</html>
